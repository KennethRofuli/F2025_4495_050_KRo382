import { useEffect, useRef, useState, useCallback } from 'react';\nimport { AppState, DeviceEventEmitter } from 'react-native';\n\n// Custom hook for performance monitoring\nexport const usePerformanceMonitor = (componentName) => {\n  const renderStart = useRef(Date.now());\n  const mountStart = useRef(Date.now());\n  \n  useEffect(() => {\n    const mountTime = Date.now() - mountStart.current;\n    if (mountTime > 200) {\n      console.warn(`ğŸŒ Slow mount: ${componentName} took ${mountTime}ms`);\n    }\n  }, [componentName]);\n  \n  useEffect(() => {\n    const renderTime = Date.now() - renderStart.current;\n    if (renderTime > 100) {\n      console.warn(`ğŸ¨ Slow render: ${componentName} took ${renderTime}ms`);\n    }\n    renderStart.current = Date.now();\n  });\n};\n\n// Custom hook for memory management\nexport const useMemoryManagement = () => {\n  useEffect(() => {\n    const handleAppStateChange = (nextAppState) => {\n      if (nextAppState === 'background') {\n        // Clear caches when app goes to background\n        DeviceEventEmitter.emit('clearCaches');\n      }\n    };\n    \n    const subscription = AppState.addEventListener('change', handleAppStateChange);\n    \n    return () => subscription?.remove();\n  }, []);\n};\n\n// Custom hook for efficient state updates\nexport const useOptimizedState = (initialValue) => {\n  const [state, setState] = useState(initialValue);\n  const stateRef = useRef(state);\n  \n  const optimizedSetState = useCallback((newValue) => {\n    // Only update if value actually changed\n    if (newValue !== stateRef.current) {\n      stateRef.current = newValue;\n      setState(newValue);\n    }\n  }, []);\n  \n  useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n  \n  return [state, optimizedSetState];\n};\n\n// Custom hook for debounced effects\nexport const useDebouncedEffect = (effect, deps, delay = 300) => {\n  useEffect(() => {\n    const handler = setTimeout(effect, delay);\n    return () => clearTimeout(handler);\n  }, [...deps, delay]);\n};\n\n// Performance utilities\nexport const performanceUtils = {\n  // Measure function execution time\n  measureTime: (name, fn) => {\n    return (...args) => {\n      const start = performance.now();\n      const result = fn.apply(this, args);\n      const end = performance.now();\n      \n      if (end - start > 50) {\n        console.log(`â±ï¸ ${name}: ${(end - start).toFixed(2)}ms`);\n      }\n      \n      return result;\n    };\n  },\n  \n  // Batch state updates for better performance\n  batchUpdates: (updates) => {\n    // In React Native, we can use unstable_batchedUpdates if needed\n    updates.forEach(update => update());\n  }\n};